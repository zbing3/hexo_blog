title: 1.python基础
date: 2016-11-18 22:41:28
categories:
tags:
  - python教程
---
  
# 1. 内置类型

## 1.1 [变量](http://opslinux.com/2016/11/20/1-1-1-%E5%8F%98%E9%87%8F/)

## 1.2 布尔

表示真假的类型，仅包含 True 和 False 两种取值

数字 0、None，以及元素为空的容器类对象都可视作 bool False，反之为 True。

```
>>> bool(0)
False

>>> bool(None)
False

>>> bool("")
False

>>> bool([])
False

>>> bool({})
False

>>> bool(1)
True

>>> bool([1,2])
True
```

bool类型支持的运算符


```
>>> a and b  # 如果 a 和 b 都是 True，结果就是 Ture ， 否则 False。
>>> a or b   #  a 和 b 至少有一个是 True 时结果是 True， 否则 False。
>>> not b    # 如果 a 是 False, 结果是 True， 如果 a 是 True，结果是 False。
```

## 1.3 数字
python本身支持整数以及浮点数。你可以对这些数字进行下表中的计算。

| 运算符 | 表述 | 示例 | 运算结果 |
| --- | --- | --- | :-- |
| + | 加法 | 1 + 1  | 2  |
| - | 减法 | 4 - 2 | 2 |
| * | 乘法 | 2 * 2 | 4 |
| / | 浮点数除法 | 7 / 2 | 3.5 |
| // | 整数除法 | 7 // 2 | 3 |
| / | 摸（求余） | 7 % 3 | 1 |
| ** | 幂 | 2 ** 2 | 4  |


### 整数

任何仅含数字的序列在 Python 中都被认为是整数：

```
>>> 5
5
```

Python还支持运算次序，因此你可在同一个表达式中使用多种运算。你还可以使用括号来修 改运算次序，让Python按你指定的次序执行运算，如下所示:


```
>>> 2 + 3*414>>> (2 + 3) * 4 20
```
在这些示例中，空格不影响Python计算表达式的方式，它们的存在旨在让你阅读代码时，能 迅速确定先执行哪些运算。

### 浮点数
Python将带小数点的数字都称为浮点数。大多数编程语言都使用了这个术语，它指出了这样一个事实:小数点可出现在数字的任何位置。每种编程语言都须细心设计，以妥善地处理浮点数， 确保不管小数点出现在什么位置，数字的行为都是正常的。

```
>>> 0.1 + 0.10.2>>> 0.2 + 0.2
0.4>>>2 * 0.10.2>>>2 * 0.20.4
```

但需要注意的是，结果包含的小数位数可能是不确定的:


```
>>> 0.2 + 0.1 
0.30000000000000004 
>>> 3 * 0.1 
0.30000000000000004
```
所有语言都存在这种问题，没有什么可担心的。Python会尽力找到一种方式，以尽可能精确地表示结果，但鉴于计算机内部表示数字的方式，这在有些情况下很难。就现在而言，暂时忽略 多余的小数位数即可。







## 1.4 字符串

字符串是由多个字符组成的序列。在Python中，用引号括起的都是字符串，字符串定义简单自由，可以是单引号、双引号或者三引号。但是个人建议使用双引号表示字符串，用单引号表示字符，和其他语言习惯保持一致。字符串是不可变序列（immutable, sequence）类型，默认存储 Unicode 文本。 python3 不再使用 str 处理二进制字节数据，改为使用 bytes 和 bytearray，前者同为不可变类型。


```
>>> s = "abc汉字"
>>> >>> len(s)
5

>>> print(ascii(s))
'abc\u6c49\u5b57'
```

> 内置函数 ascii 将目标转换为可打印 ASCII 字符组成的字符串。

构建字符串字面量很容易，单引号、双引号，以及跨行的三个引号。


```
>> "ab'c"           # 双引号。
"ab'c"

>>> 'ab"c'          # 单引号。
'ab"c'

>>> 'ab\'c'         # 引号转义。
"ab'c"

>>> """             # 多行，也可以用三个单引号。
... a
... b
... c"""
'\na\nb\nc'

>>> "a" "b" 'c'     # 自动合并多个相邻字符串。
'abc'

```

可在字面量前添加特殊指示符。


```
>>> r"abc\nd"       # raw string，禁用转义。
'abc\\nd'

>>> type(b"abc")
<class 'bytes'>

>>> type(u"abc")
<class 'str'>
```

### str() 类型转换

```
>>> str(2.2)
'2.2'
```

### 合并字符串

#### format 

```
>>> "python培训哪家强：{}".format('京峰教育')
'python培训哪家强：京峰教育'
```

```
>>> "python培训哪家强：{}, 京峰教育谁最帅？ {}".format('京峰教育', '斌哥')
'python培训哪家强：京峰教育, 京峰教育谁最帅？ 斌哥'
```

```
>>> "python培训哪家强：{0}, 京峰教育谁最帅？ {1}".format('京峰教育', '斌哥')
'python培训哪家强：京峰教育, 京峰教育谁最帅？ 斌哥'
```

### +

```
>>> '京峰' +  '教育'
'京峰教育'
```
  

### split() 分割

```
>>> s = 'a,b,c'

>>> s.split(',')
['a', 'b', 'c']
```
### join() 合并

```
>>> l = s.split(',')

>>> l
['a', 'b', 'c']

>>> ','.join(l)
'a,b,c'
```

## 1.5 [列表](http://opslinux.com/2016/11/20/1-1-2-%E5%88%97%E8%A1%A8/)
## 1.6 元组
与列表类似，元组也是由任意类型元素组成的序列。与列表不同的是，元组是不可改变的，这意味着一但元组被定义，将无法再进行增加、删除或者修改元素等操作。因此元组就像一个常量列表。从行为上看，元组（tuple）像是列表的只读版本。 但在内在实现上有根本不同，元组的只读性使其拥有更好的内存效率和性能。除无法修改外，其普通特征和列表类似。 在需要传递 “不可变” 参数时，应鼓励用元组替代列表。 它是可哈希（hashaable）结构，可用作字典（dict）主键（key）

### 使用()创建元组

可以用()创建一个空元组：

```
>>> empty_tuple = ()
>>> empty_tuple
()
>>> type(empty_tuple)
tuple
```

创建包含一个或多个元素的元组时，没一个元素后面需要跟着一个逗号，即使只包含一个元素也不能忽略：

```
>>> num = '1',
>>> num
('1',)
>>>
```

如果创建的元组所包含的元素数量超过1，最后一个元素后面的逗号可以忽略：


```
>>> num = '1', '2', '3'
>>> num
('1', '2', '3')
```
Python的交互式解释器输出元组时会自动添加一堆圆括号。你并不需要这么做——定义元组真正靠的是每个元素的后缀逗号——但如果你习惯添加一对括号也无可厚非。可以用括号将所有元素包裹起来，这会使得程序更加清晰：

```
>>> num = ('1', '2', '3')
>>> num
('1', '2', '3')
```

可以一口气将元组赋值给多个变量：


``` 
>>> a, b, c = num
>>> a
'1'
>>> b
'2'
>>> c
'3'
>>>       
```

这个过程称为元组解包

可以利用元组在一条语句中对多个变量的值进行交换，而不需借助临时变量：

```
>>> a = 1
>>> b = 2
>>> a, b = b, a
>>> a
2
>>> b
1
>>>
```

tuple() 函数可以用其他类型的数据来创建元组：

```
>>> num = [1, 2, 3]
>>> tuple(num)
(1, 2, 3)
>>>
```

### 元组与列表
在许多地方都可以用元组代替列表，但元组的方法函数与类表相比要少一些——元组没有 append() 、insert()，等等——因为一但创建元组变无法修改。既然列表更加灵活那为什么不在所有地方都是用列表呢？原因如下：

* 元组占用的空间小
* 你不会意外修改元组的值
* 可以将元组用作字典的键（详细的后面会介绍）
* 命名元组可以作为对象的代替
* 函数的参数是以元组形式是传递的

## 1.7 字典
## 1.8 集合
  
# 2. 代码格式

# 2.1. 注释
在大多数编程语言中，注释都是一项很有用的功能。随着程序越来越大、越来越复杂，就应在其中添加说明，对你解决问题的方法进行大致的阐述。注释让你能够使用自然语言在程序中添加说明。注释是程序中会被Python解释器忽略的一段文本。通过使用注释，可以解释和明确Python代码的功能，记录将来要修改的地方，甚至写下你想写的东西。在Python中使用#字符标记注释，从#开始到当前行结束的部分都是注释。你可以把注释作为单独一行：
  
单行注释：

hello.py

```
# 向大家问好
print("Hello Python people!")
```

Python解释器将忽略第一行，只执行第二行.

```
print("Hello Python people!")
```

多行注释：

```
#coding=utf-8

"""这是"nester.py"模块，提供了一个名为print_lol的函数，这个函数的作用是打印列表，其中有可能包含（也可能不包含）嵌套列表。"""
def print_lol(the_list):
    """这个函数取一个位置参数，名为"the_list",这个可以是任何python列表（也可以是包含嵌套列表的列表）。所指定的列表中的每个数据项（递归地）输出到屏幕上，各数据项各占一行。"""
    for each_item in the_list:
        if isinstance(each_item, list):
            print_lol(each_item)
        else:
            print(each_item)
```

**该编写什么样的注释?**
编写注释的主要目的是阐述代码要做什么，以及是如何做的。在开发项目期间，你对各个部分如何协同工作了如指掌，但过段时间后，有些细节你可能不记得了。当然，你总是可以通过研 究代码来确定各个部分的工作原理，但通过编写注释，以清晰的自然语言对解决方案进行概述， 可节省很多时间。要成为专业程序员或与其他程序员合作，就必须编写有意义的注释。当前，大多数软件都是合作编写的，编写者可能是同一家公司的多名员工，也可能是众多致力于同一个开源项目的人员。 训练有素的程序员都希望代码中包含注释，因此你最好从现在开始就在程序中添加描述性注释。 作为新手，最值得养成的习惯之一是，在代码中编写清晰、简洁的注释。如果不确定是否要编写注释，就问问自己，找到合理的解决方案前，是否考虑了多个解决方案。如果答案是肯定的，就编写注释对你的解决方案进行说明吧。相比回过头去再添加注释，删除多余的注释要容易得多。从现在开始，本书的示例都将使用注释来阐述代码的工作原理。
  
## 2.2 python 之禅

## 2.3 pep8

# 3. 表达式

## 3.1 控制流

### if

### for

### while

### 推导式

# 3.2  id is ==
Python中的对象包含三要素：id、type、value
其中id用来唯一标识一个对象，type标识对象的类型，value是对象的值
is判断的是a对象是否就是b对象，是通过id来判断的
==判断的是a对象的值是否和b对象的值相等，是通过value来判断的
如下代码或许可以帮助你理解。


```
>>> a = 1
>>> b = 1.0
>>> a is b
False
>>> a == b
True
>>> id(a)
12777000
>>> id(b)
14986000
>>> a = 1
>>> b = 1
>>> a is b
True
>>> a == b
True
>>> id(a)
12777000
>>> id(b)
12777000
```

> 就 CPython 而言，id 返回的就是运行期内存地址。因此这个标识属阶段性的，不能保证不被重复使用。 但对于其他实现来说，id 返回的未必就是内存地址。


  
# 4. 函数

代码复用的第一步是使用函数，它是命名的用于区分的代码段。函数可以接受任何数字或者其他类型的输入作为参数，并且返回数字或者其他类型的结果。

你可以使用函数做一下两件事情：

* 定义函数
* 调用函数

## 定义：
语句 def 在运行期创建函数对象，并与指定名字关联。

```
def func_name():
    pass  # 写入你的逻辑
```

## 参数
传入到函数的值称为参数。当调用含参数的函数时，这些参数的值会被复制给函数中的对应参数。

```
>>> def get_name(num):
...     if num == 1:
...         return '老大'
...     elif num == 2:
...         return '老二'
...
...
>>> name = get_name(1)
>>> name
'老大'
```
这个函数做了如下事情：

* 把 1 赋值给函数的内部参数 num
* 运行 if-elif 的逻辑链
* 返回一个字符串
* 将该字符串赋值给变量 name

一个函数可以接受任何数量（包括0）的任何类型的值作为输入变量，并且返回任何数量（包括0）的任何类型的结果。如果函数不显示调用 return 函数，那么会默认返回 None。

```
>>> def func_name():
...     pass
...
>>> print(func_name())
None
>>>
```

**None**

None 是 Python 中一个特殊的值，虽然它不表示任何数据，但仍然具有重要的作用。 虽然 None 作为布尔值和 False 是一样的，但是它和 False 有很多差别。下面是一个例子:

```
     >>> thing = None     >>> if thing:     ...     print("It's some thing")     ... else:     ...     print("It's no thing")     ...     It's no thing```

为了区分 None 和布尔值 False , 使用 Python 的 is 操作符:

```     >>> if thing is None:     ...     print("It's nothing")     ... else:     ...     print("It's something")     ...     It's nothing
```
这虽然是一个微妙的区别，但是对于 Python 来说是很重要的。你需要把 None 和不含 任何值的空数据结构区分开来。0 值的整型 / 浮点型、空字符串('')、空列表([])、 空元组((,))、空字典({})、空集合(set())都等价于 False，但是不等于 None。现在，快速写一个函数，输出它的参数是否是 None:

```
 >>> def is_none(thing):
...    if thing is None:...        print("It's None")...    elif thing:...        print("It's True")...    else:...        print("It's False")```
现在，运行一些测试函数:

```     >>> is_none(None)     It's None     >>> is_none(True)     It's True     >>> is_none(False)     It's False     >>> is_none(0)     It's False     >>> is_none(0.0)     It's False     >>> is_none(())     It's False
>>> is_none([])It's False>>> is_none({})It's False>>> is_none(set())It's False
```
## 位置参数
Python 处理参数的方式要比其他语言更加灵活。其中，最熟悉的参数类型是位置参数，传入参数的值是按照顺序依次复制过去的。

```
>>> def name (n1, n2, n3):
...     print('1', n1)
...     print('2', n2)
...     print('3', n3)
...
>>> name('老大', '老二', '老三')
1 老大
2 老二
3 老三
>>>
```

尽管这种方式很常见，但是位置参数的一个弊端是必须熟记没个位置的参数的含义。在调用函数name() 时误把最后一个参数当做第一个参数，会得到完全不同的结果：

```
>>> name('老二', '老大', '老三')
1 老二
2 老大
3 老三
>>>
```
## 关键字参数
为了避免位置参数带来的混乱，调用参数时可以指定对应的名字，甚至可以采用与函数定义不同的顺序调用：

```
>>> name(n2='老二', n1='老大', n3='老三')
1 老大
2 老二
3 老三
>>>
```
你也可以把位置参数和关键字参数混合起来。

```
>>> name('老大', n2='老二', n3='老三')
1 老大
2 老二
3 老三
```

如果同时出现两种参数形式，首先应该考虑的是位置参数。


```
>>> name(n2='老二', '老大', n3='老三')
  File "<ipython-input-60-2a320a67eb2a>", line 1
    name(n2='老二', '老大', n3='老三')
                     ^
SyntaxError: positional argument follows keyword argument
```
## 指定默认参数
当调用方没有提供对应的参数值时，你可以指定默认参数值。


```
>>> def name (n2, n3, n1='老大'):
...     print('1', n1)
...     print('2', n2)
...     print('3', n3)
...
...
>>> name('老二', '老三')
1 老大
2 老二
3 老三
>>>
```
> 默认参数值在函数被定义时已经计算出来，而不是在程序运行时。Python程序员经常犯的一个错误是把可变的数据类型（例如列表或者字典）当做默认参数值。

在函数 box() 在每次调用时，添加参数 arg 到一个空的列表 result, 然后打印输出一个单值列表。但存在一个问题：只有在第一次调用时列表是空的，第二次调用时就会存在之前调用的返回值：

```
>>> def box(arg, result=[]):
...     result.append(arg)
...     print(result)
...
>>> box('a')
['a']
>>> box('b')
['a', 'b']
```

如果写成下面的样子就会解决刚才的问题：

```
>>> def box(arg):
...     result = []
...     result.append(arg)
...     return result
...
>>> box('a')
['a']
>>> box('b')
['b']
```
这样的修改也是为了表明第一次调用跳过一些操作：

```
>>> def box(arg, result=None):
...     if result is None:
...         result = []
...     result.append(arg)
...     print(result)
...
>>> box('a')
['a']
>>> box('b')
['b']
```

# 5. 类
  
# 6. 文件异常

# 7. 模块





